5. Строковые интсрукции
   - MOVS/MOVSB/MOVSW/MOVSD/MOVSQ: Копируют данные из одного места в другое. MOVSB копирует байт, MOVSW - слово, MOVSD - двойное слово, MOVSQ - квадро-слово.
   - CMPS/CMPSB/CMPSW/CMPSD/CMPSQ: Сравнивают два элемента данных. CMPSB сравнивает байты, CMPSW - слова, CMPSD - двойные слова, CMPSQ - квадро-слова.
   - SCAS/SCASB/SCASW/SCASD/SCASQ: Сканируют строку в поисках байта, слова, двойного слова или квадро-слова.
   - LODS/LODSB/LODSW/LODSD/LODSQ: Загружают строку в регистр AL, AX, EAX или RAX.
   - STOS/STOSB/STOSW/STOSD/STOSQ: Записывают байт, слово, двойное слово или квадро-слово из регистра AL, AX, EAX или RAX в строку
  

## MOVS/MOVSB/MOVSW/MOVSD/MOVSQ - Move String
Инструкции MOVS, MOVSB, MOVSW, MOVSD и MOVSQ в ассемблере x86-64 используются для копирования данных из одного блока памяти в другой. Они являются частью группы строковых инструкций и работают с регистрами RSI (регистр источника) и RDI (регистр назначения). Вот как они работают:

MOVS - это общая форма инструкции, которая может быть дополнена буквой, указывающей размер операнда: B (byte, 8 бит), W (word, 16 бит), D (double word, 32 бита) или Q (quad word, 64 бита).

MOVSB копирует один байт из памяти по адресу, на который указывает RSI, в память по адресу, на который указывает RDI.

MOVSW копирует слово (2 байта) из памяти по адресу, на который указывает RSI, в память по адресу, на который указывает RDI.

MOVSD копирует двойное слово (4 байта) из памяти по адресу, на который указывает RSI, в память по адресу, на который указывает RDI.

MOVSQ копирует квадро слово (8 байтов) из памяти по адресу, на который указывает RSI, в память по адресу, на который указывает RDI.

После выполнения каждой из этих инструкций, значения регистров RSI и RDI автоматически инкрементируются или декрементируются (в зависимости от направления DF флага в регистре EFLAGS) на размер скопированных данных. Это позволяет легко копировать последовательности данных.

Инструкция REP часто используется с этими инструкциями для повторения операции копирования заданное количество раз, которое указывается в регистре RCX.

Вот пример кода, который использует MOVSB для копирования строки:
``` asm
section .data
source db 'Hello, World!', 0
dest db 13 dup(0)

section .text
global _start

_start:
    lea rsi, [source] ; адрес источника
    lea rdi, [dest]   ; адрес назначения
    mov rcx, 13       ; количество байтов для копирования
    cld               ; очистить DF флаг для инкремента RSI/RDI
    rep movsb         ; копировать строку байт

; здесь продолжение программы...
```
В этом примере, cld устанавливает направление копирования вперед, а rep movsb выполняет копирование 13 байтов из source в dest. После каждого копирования, RSI и RDI инкрементируются на 1, так как копируется 1 байт.

## CMPS/CMPSB/CMPSW/CMPSD/CMPSQ - Compare Strings
Инструкции CMPS, CMPSB, CMPSW, CMPSD и CMPSQ в ассемблере x86-64 используются для сравнения двух блоков памяти. Они работают с регистрами RSI (регистр источника) и RDI (регистр назначения), которые указывают на начало сравниваемых блоков данных. Вот как они работают:

CMPS - это общая форма инструкции, которая может быть дополнена буквой, указывающей размер операнда: B (byte, 8 бит), W (word, 16 бит), D (double word, 32 бита) или Q (quad word, 64 бита).

CMPSB сравнивает байты по адресам, на которые указывают RSI и RDI.

CMPSW сравнивает слова (2 байта) по адресам, на которые указывают RSI и RDI.

CMPSD сравнивает двойные слова (4 байта) по адресам, на которые указывают RSI и RDI.

CMPSQ сравнивает квадро слова (8 байтов) по адресам, на которые указывают RSI и RDI.

После выполнения каждой из этих инструкций, значения регистров RSI и RDI автоматически инкрементируются или декрементируются (в зависимости от направления DF флага в регистре EFLAGS) на размер сравниваемых данных. Результат сравнения отражается в флагах состояния процессора, таких как ZF (флаг нуля), SF (флаг знака) и OF (флаг переполнения).

Вот пример использования CMPSB для сравнения двух строк:
``` asm
section .data
string1 db 'Hello, World!', 0
string2 db 'Hello, World?', 0

section .text
global _start

_start:
    lea rsi, [string1] ; адрес первой строки
    lea rdi, [string2] ; адрес второй строки
    mov rcx, 13        ; количество байтов для сравнения
    cld                ; очистить DF флаг для инкремента RSI/RDI
    repe cmpsb         ; сравнить строки байт

; проверка флага ZF после сравнения
    jz equal
    jmp notequal

equal:
    ; строки равны
    ; здесь код, если строки одинаковы...

notequal:
    ; строки не равны
    ; здесь код, если строки различаются...

; здесь продолжение программы...
```
В этом примере, repe cmpsb выполняет сравнение байтов из string1 и string2 до тех пор, пока не будет достигнут конец строки или пока флаг ZF не станет равен нулю (что означает, что было найдено несовпадение). После сравнения, можно проверить флаг ZF, чтобы определить, равны ли строки.

## SCAS/SCASB/SCASW/SCASD/SCASQ - Scan String
Инструкции SCAS (Scan String) в ассемблере x86-64 используются для сканирования строки в поисках байта, слова, двойного слова или квадро слова, которые равны значению в аккумуляторе (AL, AX, EAX или RAX, в зависимости от размера операнда). Вот как работают различные варианты SCAS:

SCASB (Scan String Byte) сравнивает байт по адресу, на который указывает RDI, с байтом в AL.
SCASW (Scan String Word) сравнивает слово по адресу, на который указывает RDI, с словом в AX.
SCASD (Scan String Double Word) сравнивает двойное слово по адресу, на который указывает RDI, с двойным словом в EAX.
SCASQ (Scan String Quad Word) сравнивает квадро слово по адресу, на который указывает RDI, с квадро словом в RAX.
После выполнения инструкции SCAS, регистр RDI автоматически инкрементируется или декрементируется (в зависимости от направления DF флага в регистре EFLAGS) на размер сравниваемых данных. Результат сравнения отражается в флагах состояния процессора, таких как ZF (флаг нуля), SF (флаг знака) и OF (флаг переполнения).

Вот пример кода, который использует SCASB для поиска определенного символа в строке:
``` asm
section .data
string db 'Hello, World!', 0
char_to_find db 'W'

section .text
global _start

_start:
    lea rdi, [string] ; адрес строки
    mov al, [char_to_find] ; символ для поиска
    mov rcx, 13            ; длина строки
    cld                    ; очистить DF флаг для инкремента RDI
    repne scasb            ; сканировать строку в поисках символа

; проверка флага ZF после сканирования
    jz found
    jmp not_found

found:
    ; символ найден
    ; здесь код, если символ найден...

not_found:
    ; символ не найден
    ; здесь код, если символ не найден...

; здесь продолжение программы...
```
В этом примере, repne scasb выполняет сканирование строки в поисках символа W. Если символ найден, выполняется переход на метку found, в противном случае - на метку not_found.

## LODS/LODSB/LODSW/LODSD/LODSQ - Load String
Инструкции LODS (Load String) в ассемблере x86-64 используются для загрузки байта, слова, двойного слова или квадро слова из памяти по адресу, на который указывает регистр RSI, в аккумулятор (AL, AX, EAX или RAX, соответственно). Вот как работают различные варианты LODS:

LODSB (Load String Byte) загружает байт из памяти по адресу RSI в AL.
LODSW (Load String Word) загружает слово из памяти по адресу RSI в AX.
LODSD (Load String Double Word) загружает двойное слово из памяти по адресу RSI в EAX.
LODSQ (Load String Quad Word) загружает квадро слово из памяти по адресу RSI в RAX.
После выполнения инструкции LODS, регистр RSI автоматически инкрементируется или декрементируется (в зависимости от направления DF флага в регистре EFLAGS) на размер загружаемых данных. Это позволяет последовательно загружать данные из массива или строки.

Вот пример кода, который использует LODSB для копирования строки из одного места в другое:
``` asm
section .data
source db 'Hello, World!', 0

section .bss
destination resb 13

section .text
global _start

_start:
    lea rsi, [source]      ; адрес исходной строки
    lea rdi, [destination] ; адрес целевой строки
    mov rcx, 13            ; длина строки
    cld                    ; очистить DF флаг для инкремента RSI и RDI

copy_loop:
    lodsb                  ; загрузить байт из исходной строки в AL
    stosb                  ; сохранить байт из AL в целевую строку
    loop copy_loop         ; повторять, пока RCX не равен 0

; здесь продолжение программы...
```
В этом примере, lodsb и stosb используются вместе для копирования строки из source в destination. Каждый байт исходной строки загружается в AL, а затем сохраняется в целевой строке. Инструкция loop уменьшает RCX на 1 и повторяет цикл, пока RCX не станет равным 0.

## STOS/STOSB/STOSW/STOSD/STOSQ - Store String


## INS - Input String
Да, инструкция INS (Input String from Port) относится к строковым инструкциям в ассемблере x86. Эта инструкция используется для чтения последовательности байтов или слов из порта ввода/вывода в память, адресуемую через регистр EDI (в 32-битном режиме) или DI (в 16-битном режиме).

Строковые инструкции в ассемблере x86 облегчают обработку массивов данных и строк. Они используют регистры ESI и EDI для указания на источник и назначение данных соответственно и часто работают в сочетании с регистром ECX, который определяет количество повторений операции.

Вот пример использования INS для чтения данных из порта ввода/вывода:
``` asm
section .data
buffer resb 10 ; Резервируем буфер на 10 байт

section .text
global _start

_start:
    mov dx, 0x1234 ; Порт ввода/вывода
    mov edi, buffer ; Указатель на буфер
    mov ecx, 10 ; Количество байт для чтения

read_loop:
    insb ; Читать байт из порта в буфер
    loop read_loop ; Повторять, пока ECX не равно 0

    ; Дальнейшие инструкции...
```
INS автоматически увеличивает EDI (или DI) после каждого чтения, что позволяет последовательно заполнять буфер данными из порта. Это делает INS эффективной для операций ввода данных из внешних устройств.
